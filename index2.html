<!doctype html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    /*
! tailwindcss v3.4.1 | MIT License | https://tailwindcss.com
*/

/*
1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)
2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)
*/

*,
::before,
::after {
  box-sizing: border-box;
  /* 1 */
  border-width: 0;
  /* 2 */
  border-style: solid;
  /* 2 */
  border-color: #e5e7eb;
  /* 2 */
}

::before,
::after {
  --tw-content: '';
}

/*
1. Use a consistent sensible line-height in all browsers.
2. Prevent adjustments of font size after orientation changes in iOS.
3. Use a more readable tab size.
4. Use the user's configured `sans` font-family by default.
5. Use the user's configured `sans` font-feature-settings by default.
6. Use the user's configured `sans` font-variation-settings by default.
7. Disable tap highlights on iOS
*/

html,
:host {
  line-height: 1.5;
  /* 1 */
  -webkit-text-size-adjust: 100%;
  /* 2 */
  -moz-tab-size: 4;
  /* 3 */
  -o-tab-size: 4;
     tab-size: 4;
  /* 3 */
  font-family: ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
  /* 4 */
  font-feature-settings: normal;
  /* 5 */
  font-variation-settings: normal;
  /* 6 */
  -webkit-tap-highlight-color: transparent;
  /* 7 */
}

/*
1. Remove the margin in all browsers.
2. Inherit line-height from `html` so users can set them as a class directly on the `html` element.
*/

body {
  margin: 0;
  /* 1 */
  line-height: inherit;
  /* 2 */
}

/*
1. Add the correct height in Firefox.
2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)
3. Ensure horizontal rules are visible by default.
*/

hr {
  height: 0;
  /* 1 */
  color: inherit;
  /* 2 */
  border-top-width: 1px;
  /* 3 */
}

/*
Add the correct text decoration in Chrome, Edge, and Safari.
*/

abbr:where([title]) {
  -webkit-text-decoration: underline dotted;
          text-decoration: underline dotted;
}

/*
Remove the default font size and weight for headings.
*/

h1,
h2,
h3,
h4,
h5,
h6 {
  font-size: inherit;
  font-weight: inherit;
}

/*
Reset links to optimize for opt-in styling instead of opt-out.
*/

a {
  color: inherit;
  text-decoration: inherit;
}

/*
Add the correct font weight in Edge and Safari.
*/

b,
strong {
  font-weight: bolder;
}

/*
1. Use the user's configured `mono` font-family by default.
2. Use the user's configured `mono` font-feature-settings by default.
3. Use the user's configured `mono` font-variation-settings by default.
4. Correct the odd `em` font sizing in all browsers.
*/

code,
kbd,
samp,
pre {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  /* 1 */
  font-feature-settings: normal;
  /* 2 */
  font-variation-settings: normal;
  /* 3 */
  font-size: 1em;
  /* 4 */
}

/*
Add the correct font size in all browsers.
*/

small {
  font-size: 80%;
}

/*
Prevent `sub` and `sup` elements from affecting the line height in all browsers.
*/

sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

sub {
  bottom: -0.25em;
}

sup {
  top: -0.5em;
}

/*
1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)
2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)
3. Remove gaps between table borders by default.
*/

table {
  text-indent: 0;
  /* 1 */
  border-color: inherit;
  /* 2 */
  border-collapse: collapse;
  /* 3 */
}

/*
1. Change the font styles in all browsers.
2. Remove the margin in Firefox and Safari.
3. Remove default padding in all browsers.
*/

button,
input,
optgroup,
select,
textarea {
  font-family: inherit;
  /* 1 */
  font-feature-settings: inherit;
  /* 1 */
  font-variation-settings: inherit;
  /* 1 */
  font-size: 100%;
  /* 1 */
  font-weight: inherit;
  /* 1 */
  line-height: inherit;
  /* 1 */
  color: inherit;
  /* 1 */
  margin: 0;
  /* 2 */
  padding: 0;
  /* 3 */
}

/*
Remove the inheritance of text transform in Edge and Firefox.
*/

button,
select {
  text-transform: none;
}

/*
1. Correct the inability to style clickable types in iOS and Safari.
2. Remove default button styles.
*/

button,
[type='button'],
[type='reset'],
[type='submit'] {
  -webkit-appearance: button;
  /* 1 */
  background-color: transparent;
  /* 2 */
  background-image: none;
  /* 2 */
}

/*
Use the modern Firefox focus style for all focusable elements.
*/

:-moz-focusring {
  outline: auto;
}

/*
Remove the additional `:invalid` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)
*/

:-moz-ui-invalid {
  box-shadow: none;
}

/*
Add the correct vertical alignment in Chrome and Firefox.
*/

progress {
  vertical-align: baseline;
}

/*
Correct the cursor style of increment and decrement buttons in Safari.
*/

::-webkit-inner-spin-button,
::-webkit-outer-spin-button {
  height: auto;
}

/*
1. Correct the odd appearance in Chrome and Safari.
2. Correct the outline style in Safari.
*/

[type='search'] {
  -webkit-appearance: textfield;
  /* 1 */
  outline-offset: -2px;
  /* 2 */
}

/*
Remove the inner padding in Chrome and Safari on macOS.
*/

::-webkit-search-decoration {
  -webkit-appearance: none;
}

/*
1. Correct the inability to style clickable types in iOS and Safari.
2. Change font properties to `inherit` in Safari.
*/

::-webkit-file-upload-button {
  -webkit-appearance: button;
  /* 1 */
  font: inherit;
  /* 2 */
}

/*
Add the correct display in Chrome and Safari.
*/

summary {
  display: list-item;
}

/*
Removes the default spacing and border for appropriate elements.
*/

blockquote,
dl,
dd,
h1,
h2,
h3,
h4,
h5,
h6,
hr,
figure,
p,
pre {
  margin: 0;
}

fieldset {
  margin: 0;
  padding: 0;
}

legend {
  padding: 0;
}

ol,
ul,
menu {
  list-style: none;
  margin: 0;
  padding: 0;
}

/*
Reset default styling for dialogs.
*/

dialog {
  padding: 0;
}

/*
Prevent resizing textareas horizontally by default.
*/

textarea {
  resize: vertical;
}

/*
1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)
2. Set the default placeholder color to the user's configured gray 400 color.
*/

input::-moz-placeholder, textarea::-moz-placeholder {
  opacity: 1;
  /* 1 */
  color: #9ca3af;
  /* 2 */
}

input::placeholder,
textarea::placeholder {
  opacity: 1;
  /* 1 */
  color: #9ca3af;
  /* 2 */
}

/*
Set the default cursor for buttons.
*/

button,
[role="button"] {
  cursor: pointer;
}

/*
Make sure disabled buttons don't get the pointer cursor.
*/

:disabled {
  cursor: default;
}

/*
1. Make replaced elements `display: block` by default. (https://github.com/mozdevs/cssremedy/issues/14)
2. Add `vertical-align: middle` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)
   This can trigger a poorly considered lint error in some tools but is included by design.
*/

img,
svg,
video,
canvas,
audio,
iframe,
embed,
object {
  display: block;
  /* 1 */
  vertical-align: middle;
  /* 2 */
}

/*
Constrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)
*/

img,
video {
  max-width: 100%;
  height: auto;
}

/* Make elements with the HTML hidden attribute stay hidden by default */

[hidden] {
  display: none;
}

*, ::before, ::after {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-gradient-from-position:  ;
  --tw-gradient-via-position:  ;
  --tw-gradient-to-position:  ;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(59 130 246 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
}

::backdrop {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-gradient-from-position:  ;
  --tw-gradient-via-position:  ;
  --tw-gradient-to-position:  ;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(59 130 246 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
}

.col-span-10 {
  grid-column: span 10 / span 10;
}

.col-span-8 {
  grid-column: span 8 / span 8;
}

.col-span-2 {
  grid-column: span 2 / span 2;
}

.col-start-2 {
  grid-column-start: 2;
}

.col-start-3 {
  grid-column-start: 3;
}

.grid {
  display: grid;
}

.hidden {
  display: none;
}

.h-full {
  height: 100%;
}

.w-full {
  width: 100%;
}

.grid-cols-1 {
  grid-template-columns: repeat(1, minmax(0, 1fr));
}

.grid-cols-3 {
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.grid-cols-4 {
  grid-template-columns: repeat(4, minmax(0, 1fr));
}

.grid-cols-12 {
  grid-template-columns: repeat(12, minmax(0, 1fr));
}

.gap-5 {
  gap: 1.25rem;
}

.overflow-hidden {
  overflow: hidden;
}

.rounded-xl {
  border-radius: 0.75rem;
}

.border {
  border-width: 1px;
}

.bg-neutral-500 {
  --tw-bg-opacity: 1;
  background-color: rgb(115 115 115 / var(--tw-bg-opacity));
}

.bg-red-400 {
  --tw-bg-opacity: 1;
  background-color: rgb(248 113 113 / var(--tw-bg-opacity));
}

.object-cover {
  -o-object-fit: cover;
     object-fit: cover;
}

.object-right {
  -o-object-position: right;
     object-position: right;
}

.object-left {
  -o-object-position: left;
     object-position: left;
}

.pb-3 {
  padding-bottom: 0.75rem;
}

.pl-10 {
  padding-left: 2.5rem;
}

.pr-10 {
  padding-right: 2.5rem;
}

.pt-3 {
  padding-top: 0.75rem;
}

.text-center {
  text-align: center;
}

.text-3xl {
  font-size: 1.875rem;
  line-height: 2.25rem;
}

.text-4xl {
  font-size: 2.25rem;
  line-height: 2.5rem;
}

.text-lg {
  font-size: 1.125rem;
  line-height: 1.75rem;
}

.font-bold {
  font-weight: 700;
}

.underline {
  text-decoration-line: underline;
}

.hover\:bg-neutral-200:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(229 229 229 / var(--tw-bg-opacity));
}

.hover\:bg-red-200:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(254 202 202 / var(--tw-bg-opacity));
}
  </style>
  
  <style>
    canvas {
        border: 1px solid black;
    }
  </style>
</head>
<body>
  <h1 class="text-3xl font-bold underline">
    Projet chat de course.
  </h1>
  <div class="grid grid-cols-1 text-4xl text-center">
    <canvas id="gameCanvas" class="w-full"  height="300"></canvas>
    <div class="grid grid-cols-3 gap-5 pl-10 pr-10">
      <button class="bg-neutral-500 rounded-xl hover:bg-neutral-200 pt-3 pb-3" id="rotateACWBtn">↪️</button>
      <button class="bg-neutral-500 rounded-xl hover:bg-neutral-200" id="moveNorthBtn">⬆️</button>
      <button class="bg-neutral-500 rounded-xl hover:bg-neutral-200" id="rotateCWBtn">↩️</button>
      <button class="bg-neutral-500 rounded-xl pt-3 pb-3 hover:bg-neutral-200" id="moveWestBtn">⬅️</button>
      <button class="bg-neutral-500 rounded-xl hover:bg-neutral-200" id="takePhotoBtn">📸</button>
      <button class="bg-neutral-500 rounded-xl hover:bg-neutral-200" id="moveEastBtn">➡️</button>
      <button class="col-start-2 bg-neutral-500 rounded-xl pt-3 pb-3 hover:bg-neutral-200" id="moveSouthBtn">⬇️</button>
      <button class="bg-red-400 rounded-xl pt-3 pb-3 hover:bg-red-200" id="deleteBorder">🗑️</button>
  </div>
    <div>
        <p class="text-lg">Votre position : <span class="text-lg" id="playerPosition"></span></p>
    </div>
    <div class="grid grid-cols-4 gap-5">
      <button class="bg-neutral-500 rounded-xl pt-3 pb-3 col-start-2 hover:bg-neutral-200" id="zoomIn">🔎</button>
      <button class="bg-neutral-500 rounded-xl pt-3 pb-3 hover:bg-neutral-200" id="zoomOut">🗺️</button>
    </div>
    <div class="grid grid-cols-12">
      <image class="col-span-2 h-full object-cover overflow-hidden object-right" id="image1"></image>
      <video class="col-start-3 col-span-8" id="video" autoplay></video>
      <image class="col-span-2 h-full object-cover overflow-hidden object-left" id="image2"></image>
    </div>
    <div id="saveOfPicturesDiv" class="hidden">

    </div>
    
    
  </div>
  <script>
    class Border {
    constructor() {
        this.imageNumber = [];
    }

    addImage(imageNumber) {
        this.imageNumber.push(imageNumber);
    }

    removeImage(imageNumber) {
        const index = this.imageNumber.indexOf(imageNumber);
        if (index !== -1) {
            this.imageNumber.splice(index, 1);
        }
    }

    getImage() {
        return this.imageNumber;
    }
}

  </script>
  <script>
    class Cell {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.northBorder;
        this.southBorder;
        this.westBorder;
        this.estBorder;
    }

    addImage(o,image){
        switch (o) {
            case 2:
                if (!(this.northBorder instanceof Border)) {
                    this.northBorder = new Border();
                }
                this.northBorder.addImage(image);
                break;
            case 3:
                if (!(this.estBorder instanceof Border)) {
                    this.estBorder = new Border();
                }
                this.estBorder.addImage(image);
                break;
            case 0:
                if (!(this.southBorder instanceof Border)) {
                    this.southBorder = new Border();
                }
                this.southBorder.addImage(image);
                break;
            case 1:
                if (!(this.westBorder instanceof Border)) {
                    this.westBorder = new Border();
                }
                this.westBorder.addImage(image);
                break;
        }
    }

    getLastImage(o){
        switch (o) {
            case 2:
                if ((this.northBorder instanceof Border)) {
                    return this.northBorder.getImage()[0];
                }
                break;
            case 3:
                if ((this.estBorder instanceof Border)) {
                    return this.estBorder.getImage()[0];
                }
                break;
            case 0:
                if ((this.southBorder instanceof Border)) {
                    return this.southBorder.getImage()[0];
                }
                break;
            case 1:
                if ((this.westBorder instanceof Border)) {
                    return this.westBorder.getImage()[0];
                }               
                break;
        }
    }

    removeBorder(orientation){
        switch (orientation) {
            case 2:
                if ((this.northBorder instanceof Border)) {
                    this.northBorder = null;
                }
                break;
            case 3:
                if ((this.estBorder instanceof Border)) {
                    this.estBorder = null;
                }
                break;
            case 0:
                if ((this.southBorder instanceof Border)) {
                    this.southBorder = null;
                }
                break;
            case 1:
                if ((this.westBorder instanceof Border)) {
                    this.westBorder = null;
                }
                break;
        }
    }

    getX(){
        return this.x;
    }

    getY(){
        return this.y;
    }

    setNorthBorder(border) {
        this.northBorder = border;
    }

    setWestBorder(border) {
        this.westBorder = border;
    }

    setEastBorder(border) {
        this.eastBorder = border;
    }

    setSouthBorder(border) {
        this.southBorder = border;
    }

    getWestBorder() {
        return this.westBorder;
    }

    getEastBorder() {
        return this.eastBorder;
    }

    getSouthBorder() {
        return this.southBorder;
    }

    getNorthBorder(){
        return this.northBorder;
    }


}
  </script>
  <script >
    class Player {
    constructor(x, y, orientation) {
        this.x = x;
        this.y = y;
        this.orientation = orientation;
    }

    getCellPositionToTakeImage() {
        switch (this.orientation) {
            case 0:
                return {x: this.x, y: this.y - 1, o: this.orientation};
            case 1:
                return {x: this.x + 1, y: this.y, o: this.orientation};
            case 2:
                return {x: this.x, y: this.y + 1, o: this.orientation};
            case 3:
                return {x: this.x - 1, y: this.y, o: this.orientation};
            default:
                return {x: this.x, y: this.y, o: this.orientation}; // Valeurs par défaut si l'orientation n'est pas valide
        }
    }

    getCellsNeighbourPositionToFrontCell() {
        switch (this.orientation) {
            case 0:
                return {x1: this.x-1, y1: this.y - 1, x2: this.x+1, y2: this.y - 1};
            case 1:
                return {x1: this.x+1, y1: this.y - 1, x2: this.x+1, y2: this.y + 1};
            case 2:
                return {x1: this.x-1, y1: this.y + 1, x2: this.x+1, y2: this.y +1};
            case 3:
                return {x1: this.x-1, y1: this.y - 1, x2: this.x-1, y2: this.y + 1};
            default:
                return; // Valeurs par défaut si l'orientation n'est pas valide
        }
    }

    moveWest() {
        this.x -= 1;
    }

    moveEast() {
        this.x += 1;
    }

    moveNorth() {
        this.y -= 1;
    }

    moveSouth() {
        this.y += 1;
    }

    rotateCW() {
        this.orientation++;
        this.orientation = this.orientation%4;
    }

    rotateACW() {
        this.orientation--;
        if(this.orientation === -1){
            this.orientation = 3;
        }
    }

    getX(){
        return this.x;
    }

    getY(){
        return this.y;
    }

    getOrientation(){
        return this.orientation;
    }
}

  </script>
  <script>
    class App {
    constructor(player) {
        this.player = player;
        this.cells = [];
    }

    takeImage(image) {
        const cellPosition = this.player.getCellPositionToTakeImage();
        const xCell = cellPosition.x;
        const yCell = cellPosition.y;
        const o = cellPosition.o;
        const result = this.checkIfCellAlreadyExist(xCell, yCell);

        if (result instanceof Cell) {
            result.addImage(o, image);
        } else {
            const newCell = new Cell(xCell, yCell);
            newCell.addImage(o, image);
            this.cells.push(newCell);
        }     
    }

    getNearestImagesValues(){
        var imageLeft = null;
        var imageRight = null;
        const neighbourCells = this.player.getCellsNeighbourPositionToFrontCell();
        var result = this.checkIfCellAlreadyExist(neighbourCells.x1, neighbourCells.y1)
        if (result instanceof Cell) {
            imageLeft = result.getLastImage(this.player.getOrientation());
        }
        var result = this.checkIfCellAlreadyExist(neighbourCells.x2, neighbourCells.y2)
        if (result instanceof Cell) {
            imageRight = result.getLastImage(this.player.getOrientation());
        }
        return {imageLeft: imageLeft, imageRight: imageRight};
    }

    checkIfCellAlreadyExist(xCell, yCell) {
        for (const cell of this.cells) {
            if (cell.getX() === xCell && cell.getY() === yCell) {
                return cell;
            }
        }
        return false;
    }   

    removeImage() {
    }

    moveWest() {
        this.player.moveWest();
    }

    moveEast() {
        this.player.moveEast();
    }

    moveNorth() {
        this.player.moveNorth();
    }

    moveSouth() {
        this.player.moveSouth();
    }

    rotateCW() {
        this.player.rotateCW();
    }

    rotateACW() {
        this.player.rotateACW();
    }

    getPlayerPosition(){
        return { x: this.player.getX(), y: this.player.getY() };
    }

    getPlayerOrientation(){
        return this.player.getOrientation();
    }

    getCells(){
        return this.cells;
    }

    deleteBorder(){
        const cellPosition = this.player.getCellPositionToTakeImage();
        const xCell = cellPosition.x;
        const yCell = cellPosition.y;
        const o = cellPosition.o;
        const result = this.checkIfCellAlreadyExist(xCell, yCell);

        if (result instanceof Cell) {
            result.removeBorder(o);
        }  
    }
}
  </script>
  <script defer>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

const moveNorthBtn = document.getElementById('moveNorthBtn');
const moveWestBtn = document.getElementById('moveWestBtn');
const moveEastBtn = document.getElementById('moveEastBtn');
const moveSouthBtn = document.getElementById('moveSouthBtn');
const rotateCWBtn = document.getElementById('rotateCWBtn');
const rotateACWBtn = document.getElementById('rotateACWBtn');
const playerPositionSpan = document.getElementById('playerPosition');
const deleteBorder = document.getElementById('deleteBorder');
const zoomOut = document.getElementById('zoomOut');
const zoomIn = document.getElementById('zoomIn');
const video = document.getElementById('video');
const image1 = document.getElementById('image1');
const image2 = document.getElementById('image2');


const gridSize = canvas.width;
var nuberOfCell = 11;
var cellSize = canvas.width/nuberOfCell;
var playerSize = cellSize/2;
var pictureNumber =0;

const app = new App(new Player(0,0,0));

// Dessiner la grille
function drawGrid() {
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.setLineDash([cellSize/7, cellSize/7]); // Définit le motif de pointillés (5 pixels de trait, 5 pixels d'espacement)
    ctx.strokeStyle = 'black'; // Couleur des lignes
    ctx.lineWidth = 1; // 1 pixels d'épaisseur
    for (let x = 0; x < canvas.width; x += cellSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
    }
    for (let y = 0; y < canvas.height; y += cellSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
    }
    ctx.setLineDash([]); // Réinitialise le motif de ligne pour les prochains dessins
}

// Dessiner les bordures
function drawBorders(playerX,playerY) {
    const gap = 3;
    renderDistance = Math.abs(Math.ceil(gridSize/cellSize/2));
    ctx.strokeStyle = 'blue';
    ctx.lineWidth = 3; // 2 pixels d'épaisseur
    // Dessinez les bordures de la cellule dans laquelle se trouve le joueur
    for (const cell of app.getCells()) {
        const x = cell.getX();
        const y = cell.getY();
        if(!(x-playerX > renderDistance || y-playerY > renderDistance)){
            const absX = (canvas.width-cellSize) / 2 + (x-playerX)*cellSize ;
            const absY = (canvas.height-cellSize) / 2 + (y-playerY)*cellSize ;

            if (cell.northBorder) {
                ctx.beginPath();
                ctx.moveTo(absX, absY+gap);
                ctx.lineTo(absX + cellSize, absY+gap);
                ctx.stroke();
            }
            if (cell.southBorder) {
                ctx.beginPath();
                ctx.moveTo(absX, absY + cellSize-gap);
                ctx.lineTo(absX + cellSize, absY + cellSize-gap);
                ctx.stroke();
            }
            if (cell.westBorder) {
                ctx.beginPath();
                ctx.moveTo(absX+gap, absY);
                ctx.lineTo(absX+gap, absY + cellSize);
                ctx.stroke();
            }
            if (cell.estBorder) {
                ctx.beginPath();
                ctx.moveTo(absX + cellSize-gap, absY);
                ctx.lineTo(absX + cellSize-gap, absY + cellSize);
                ctx.stroke();
            }
        }
    }
}

// Dessiner le joueur
function drawPlayer() {
    const o = app.getPlayerOrientation();
    const playerX = canvas.width / 2; // Centre horizontal du canevas
    const playerY = canvas.height / 2; // Centre vertical du canevas

    ctx.fillStyle = 'red';
    // Dessine la forme de la flèche en fonction de l'orientation
    ctx.fillRect(playerX-playerSize/2, playerY-playerSize/2, playerSize, playerSize);
    if (o === 0) {
        ctx.fillRect(playerX, playerY,3,-30)
    } else if (o === 1) {
        ctx.fillRect(playerX, playerY,30,3)
    } else if (o === 2) {
        ctx.fillRect(playerX, playerY,3,30)
    } else if (o === 3) {
        ctx.fillRect(playerX, playerY,-30,3)
    }
}

// Mettez à jour la position du joueur
function updatePlayerPosition(x, y) {
    playerPositionSpan.textContent = `(${x}, ${y})`;
}

function draw(){
    const playerPosition = app.getPlayerPosition();
    drawGrid();
    drawPlayer(); // Position du joueur
    updatePlayerPosition(playerPosition.x, playerPosition.y); // Met à jour la position initiale du joueur
    drawBorders(playerPosition.x, playerPosition.y);
    setPictures();
}

function setPictures(){
    const imagesToDiplay = app.getNearestImagesValues();
    if((imagesToDiplay.imageLeft != null)){
        const canvasElementImageLeft = document.getElementById('canvas'+imagesToDiplay.imageLeft.toString());
        image1.src = canvasElementImageLeft.toDataURL();
    }else{
        image1.src = '';
    }
    if((imagesToDiplay.imageRight != null)){
        const canvasElementImageRight = document.getElementById('canvas'+imagesToDiplay.imageRight.toString());
        image2.src = canvasElementImageRight.toDataURL();
    }else{
        image2.src = '';
    }
}

moveNorthBtn.addEventListener('click', function() {
    app.moveNorth();
    draw();
});

moveWestBtn.addEventListener('click', function() {
    app.moveWest();
    draw();
});

moveEastBtn.addEventListener('click', function() {
    app.moveEast();
    draw();
});

moveSouthBtn.addEventListener('click', function() {
    app.moveSouth();
    draw();
});

rotateCWBtn.addEventListener('click', function() {
    app.rotateCW();
    draw();
});

rotateACWBtn.addEventListener('click', function() {
    app.rotateACW();
    draw();
});

deleteBorder.addEventListener('click', function() {
    app.deleteBorder();
    draw();
});

zoomIn.addEventListener('click', function() {
    if(nuberOfCell > 7){
        nuberOfCell = nuberOfCell -2;
        cellSize = canvas.width/nuberOfCell;
        playerSize = cellSize/2;
        draw();
    }
});

zoomOut.addEventListener('click', function() {
    if(nuberOfCell < 30){
        nuberOfCell = nuberOfCell +2;
        cellSize = canvas.width/nuberOfCell;
        playerSize = cellSize/2;
        draw();
    }
});

document.getElementById('takePhotoBtn').addEventListener('click', function() {
    // Récuperer la photo de la source
    // Créer un canvas temporaire pour capturer l'image de la vidéo
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = video.videoWidth;
    tempCanvas.height = video.videoHeight;
    const tempCtx = tempCanvas.getContext('2d');

    // Dessiner le contenu de la vidéo sur le canvas temporaire
    tempCtx.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);

    // Obtenir les données de l'image sous forme de base64
    const imageData = tempCanvas.toDataURL('CDCnumber'+ pictureNumber.toString() + '/png');

    // Créer un lien pour télécharger l'image
    const link = document.createElement('a');
    link.href = imageData;
    link.download = 'CDCnumber'+ pictureNumber.toString() + '/png';
    link.click();
    //
    ///image1.src = imageData; 
    const canvasPictureSaving = document.createElement('canvas');
    const ctxSaving = canvasPictureSaving.getContext('2d');
    canvasPictureSaving.width = video.videoWidth;
    canvasPictureSaving.height = video.videoHeight;
    canvasPictureSaving.setAttribute('id', 'canvas' + pictureNumber.toString());
    ctxSaving.drawImage(video, 0, 0, canvasPictureSaving.width, canvasPictureSaving.height);
    // Ajouter le canvas comme enfant de la div
    saveOfPicturesDiv.appendChild(canvasPictureSaving);
    
    

    app.takeImage(pictureNumber);
    pictureNumber++;
    draw();
});

draw();



//Racourcis claviers :
// Ajouter un écouteur d'événements pour les touches de direction (flèches)
document.addEventListener('keydown', function(event) {
    const keyCode = event.keyCode;

    // Gérer les touches de direction
    switch(keyCode) {
        case 65:
            app.rotateACW();
            draw();
            break;
        case 69:
            app.rotateCW();
            draw();
            break;
        case 81:
            app.moveWest();
            draw();
            break;
        case 90: 
            app.moveNorth();
            draw();
            break;
        case 68: 
            app.moveEast();
            draw();
            break;
        case 83: 
            app.moveSouth();
            draw();
            break;
        case 67:
            app.takeImage(0);
            draw();
            break;
        default:
            break;
    }
});


// Obtenir un accès à la caméra de l'appareil
navigator.mediaDevices.getUserMedia({ video: { facingMode: { exact: "environment" }} })
    .then(function(stream) {
        video.srcObject = stream;
        video.play();
    })
    .catch(function(err) {
        console.error('Error accessing camera:', err);
    });
  </script>
</body>
</html>